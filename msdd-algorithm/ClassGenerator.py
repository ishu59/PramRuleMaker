from typing import Dict, List
from pprint import pprint
import json

class PRAMClassGenerator:
    def __init__(self, json_str = None, json_file_path = None):
        self.data = None
        if json_str is None and json_file_path is None:
            # raise Exception("Invalid file path or json string. Please provide valid file path for json data or provide json string")
            print("No valid json file has been loaded")
        if json_str is None:
            with open(json_file_path) as file:
                self.data = json.load(file)
        else:
            self.data = json.loads(json_str)
        # if self.data is not None:

    def generate_class_from_json(self, data, output_file=None, output_file_path = None):
        if data is None and self.data is None:
            raise Exception("Invalid file path or json string. Please provide valid file path for json data or provide json string")
        elif data is None:
            data = self.data
        else:
            data = json.loads(data)
        if output_file is None:
            output_file = 'Autogenerated'
        if output_file_path is not None:
            op_file_name = output_file_path + '/' + output_file + '.py'
        else:
            op_file_name = output_file + '.py'
        class_stmt = '''
from pram.data import GroupSizeProbe, ProbeMsgMode
from pram.entity import Group, GroupQry, GroupSplitSpec, Site
from pram.rule import GoToRule, DiscreteInvMarkovChain, TimeInt, Rule
from pram.sim import Simulation

class {}(Rule):

    def apply(self, pop, group, iter, t):
        '''.format(output_file)

        print(class_stmt)
        # why attribute is list?
        # bcoz we can multiple attribute like flue location other in a single rule
        # why attribute is there in successor list?
        # bcoz attribute A can have rules affecting attribute B population, can also have multiple attributes
        conditional_start = "if "
        conditional_head = "group.has_attr("
        conditional_stmt = None #use dict string str(dict) with key from attribute value from precursor
        conditional_and = ' and '
        conditional_tail = "): "
        consequent_head = "return["
        consequent_body_start = "GroupSplitSpec("
        consequent_body_end = "),"
        consequent_body_prob_text = "p = "
        consequent_body_prob_val = None # just the prob value as float
        consequent_body_attr_text = ", attr_set="
        consequent_body_attr_val = None #use successor dict string str(dict) with key from successor attribute value from successor value
        consequent_tail = "]"
        comma_str = ', '
        rule_buffer = []
        for rule in data:
            rule: Dict
            precursor_buffer = ''
            precursor_attribute:List = rule.get("attribute")
            precursor:List = rule.get("precursor")
            successor:List = rule.get("successor")
            conditions = dict(zip(precursor_attribute, precursor))
            # print(conditions)
            precursor_buffer+= conditional_start + conditional_head+ str(conditions) + conditional_tail + consequent_head
            successor_buffer = ''
            probability = 0
            for subsequent in successor:
                successor_attribute: List = subsequent.get("successorAttribute")
                value: List = subsequent.get("value")
                probability = subsequent.get("probability")
                final_successor = dict(zip(successor_attribute,value))
                conseq = consequent_body_start + consequent_body_prob_text + str(probability) +  consequent_body_attr_text + str(final_successor) + consequent_body_end
                successor_buffer += conseq
                # print(final_successor, probability)
                # print(conseq)
            rule_stmt = precursor_buffer + successor_buffer + consequent_tail
            rule_buffer.append(rule_stmt)
        # pprint(rule_buffer)
        for item in rule_buffer:
            class_stmt = class_stmt + '\n        '+ item
        print(class_stmt)
        with open(op_file_name,'w') as file:
            file.write(class_stmt)
        return class_stmt

def test_hd_rule():
    pcg = PRAMClassGenerator(json_file_path='jsonData/hdfile.json')
    pcg.generate_class_from_json(data=None, output_file='HeartDisease', output_file_path='./sim')

def test_simple_SIR():
    pcg = PRAMClassGenerator(json_file_path='jsonData/sampleRule.json')
    pcg.generate_class_from_json(data=None, output_file='SIRFluRule', output_file_path='./sim')

if __name__ == '__main__':
    print('======================== Running Program =====================================')
    test_hd_rule()
    # test_simple_SIR()